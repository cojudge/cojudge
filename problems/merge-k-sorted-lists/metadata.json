{
  "id": "merge-k-sorted-lists",
  "title": "43. Merge K Sorted Lists",
  "difficulty": "Hard",
  "link": "https://leetcode.com/problems/merge-k-sorted-lists/",
  "category": "linked-list",
  "examples": [
    {
      "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
      "output": "[1,1,2,3,4,4,5,6]"
    },
    {
      "input": "lists = []",
      "output": "[]"
    },
    {
      "input": "lists = [[]]",
      "output": "[]"
    }
  ],
  "starterCode": {
    "java": "/*\nDefinition for singly-linked list. \nListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n*/\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        \n    }\n}",
    "python": "# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists):\n        pass\n",
    "cpp": "/*\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(): val(0), next(nullptr) {}\n    ListNode(int x): val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next): val(x), next(next) {}\n};\n*/\n#include <vector>\nusing namespace std;\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        return nullptr;\n    }\n};\n"
  },
  "testCases": [
    {
      "lists": [
        "[1,4,5]",
        "[1,3,4]",
        "[2,6]"
      ]
    },
    {
      "lists": []
    },
    {
      "lists": [
        "[]"
      ]
    },
    {
      "lists": [
        "[1]",
        "[1]"
      ]
    }
  ],
  "functionName": "mergeKLists",
  "params": [
    {
      "name": "lists",
      "type": "list_node_array"
    }
  ],
  "outputType": "list_node",
  "hints": [
    "Use a min-heap (priority queue) of size k to always extract the smallest head; push the next node from the extracted list. Time: O(N log k).",
    "Alternatively, merge lists in a divide-and-conquer fashion (pairwise merge like merge sort). Time: O(N log k), Space: O(1) extra (if iterative).",
    "Re-use existing nodes by rewiring next pointers; you don't need to allocate new nodes.",
    "Edge cases: empty array, lists containing null heads, and lists with only one element."
  ]
}
