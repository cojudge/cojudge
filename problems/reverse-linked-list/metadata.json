{
  "id": "reverse-linked-list",
  "title": "40. Reverse Linked List",
  "difficulty": "Easy",
  "link": "https://leetcode.com/problems/reverse-linked-list/",
  "category": "linked-list",
  "examples": [
    {
      "input": "head = [1,2,3,4,5]",
      "output": "[5,4,3,2,1]"
    },
    {
      "input": "head = [1,2]",
      "output": "[2,1]"
    },
    {
      "input": "head = []",
      "output": "[]"
    }
  ],
  "starterCode": {
    "java": "/*\nDefinition for singly-linked list. \nListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n*/\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        \n    }\n}",
    "python": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseList(self, head):\n        # TODO: implement in-place reversal and return new head\n        pass\n",
    "cpp": "/*\nDefinition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(): val(0), next(nullptr) {}\n    ListNode(int x): val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next): val(x), next(next) {}\n};\n*/\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        \n    }\n};\n"
  },
  "testCases": [
    {
      "head": "[1,2,3,4,5]"
    },
    {
      "head": "[1,2]"
    },
    {
      "head": "[]"
    },
    {
      "head": "[0]"
    },
    {
      "head": "[1,1,1,1]"
    },
    {
      "head": "[2,1,3,5,6,4,7]"
    },
    {
      "head": "[10,20,30,40,50,60,70,80,90,100]"
    }
  ],
  "functionName": "reverseList",
  "params": [
    {
      "name": "head",
      "type": "list_node"
    }
  ],
  "outputType": "list_node",
  "hints": [
    "Iterative approach: maintain prev, curr, next pointers; set curr.next = prev while walking forward.",
    "At the end, prev is the new head; return it.",
    "Recursive approach: reverse from head.next, then set head.next.next = head and head.next = null.",
    "Avoid creating new nodes; just rewire next pointers."
  ]
}
